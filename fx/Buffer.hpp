// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "Types.hpp"
#include "Allocator.hpp"
#include <cstring>
#include <exception>
#include <type_traits>

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace fx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// With great power comes undefined behaviour.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename T> class Buffer
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Data.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		T* Data;
		u64 Size;
		Allocator* Alloc;
		template <typename C> friend class Buffer; // Friend of it self. Alexa, this is so sad. Play despacito.
		public:

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Default constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Buffer ( void ) : Data(nullptr), Size(0), Alloc(&AllocDef) {}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Explicit constructor: Non default allocator.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Buffer ( Allocator& _Alloc ) : Data(nullptr), Size(0), Alloc(&_Alloc) {}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Explicit constructor: Resize on construction.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Buffer ( const u64 _Size, Allocator& _Alloc = AllocDef ) : Data(nullptr), Size(0), Alloc(&_Alloc) { this->resize(_Size); }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Copy constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Buffer ( const Buffer<T>& _Buffer ) : Data(nullptr), Size(0), Alloc(_Buffer.Alloc)
		{
			this->resize(_Buffer.Size);
			std::memcpy(this->Data, _Buffer.Data, this->sizeInBytes());
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Casting copy constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		template<typename C> Buffer ( const Buffer<C>& _Buffer ) : Data(nullptr), Size(0), Alloc(_Buffer.Alloc)
		{
			if((_Buffer.sizeInBytes() % sizeof(T)) == 0)
			{
				this->resize(_Buffer.sizeInBytes() / sizeof(T));
				std::memcpy(this->Data, _Buffer.Data, this->sizeInBytes());
			}

			else throw std::bad_cast();
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Move constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Buffer ( Buffer<T>&& _Buffer ) noexcept : Data(_Buffer.Data), Size(_Buffer.Size), Alloc(_Buffer.Alloc) { _Buffer.Data = nullptr; }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Casting move constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		template<typename C> Buffer ( Buffer<C>&& _Buffer ) : Data(nullptr), Size(0), Alloc(_Buffer.Alloc)
		{
			if((_Buffer.sizeInBytes() % sizeof(T)) == 0)
			{
				this->Size = _Buffer.sizeInBytes() / sizeof(T);
				this->Data = reinterpret_cast<T*>(_Buffer.Data);
				_Buffer.Data = nullptr;
			}

			else throw std::bad_cast();
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Destructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		~Buffer ( void ) { this->free(); }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Copy assignment.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto operator= ( const Buffer<T>& _Buffer ) -> Buffer<T>&
		{
			if(this != &_Buffer)
			{
				this->resize(_Buffer.Size, *_Buffer.Alloc);
				std::memcpy(this->Data, _Buffer.Data, this->sizeInBytes());
			}

			return *this;
		}
		
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Casting copy assignment.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		template<typename C> auto operator= ( const Buffer<C>& _Buffer ) noexcept -> Buffer<T>& 
		{
			if((_Buffer.sizeInBytes() % sizeof(T)) == 0)
			{
				this->resize(_Buffer.sizeInBytes() / sizeof(T), *_Buffer.Alloc);
				std::memcpy(this->Data, _Buffer.Data, this->sizeInBytes());
			}

			else throw std::bad_cast();

			return *this;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Move assignment.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto operator= ( Buffer<T>&& _Buffer ) noexcept -> Buffer<T>& 
		{
			if(this != &_Buffer)
			{
				this->free();
				
				this->Data = _Buffer.Data;
				this->Size = _Buffer.Size;
				this->Alloc = _Buffer.Alloc;

				_Buffer.Data = nullptr;
			}

			return *this;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Casting move assignment. For cases when you want reinterpret buffer object instead buffer pointer.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		template<typename C> auto operator= ( Buffer<C>&& _Buffer ) -> Buffer<T>&
		{
			if((_Buffer.sizeInBytes() % sizeof(T)) == 0)
			{
				this->free();
				
				this->Data = reinterpret_cast<T*>(_Buffer.Data);
				this->Size = _Buffer.sizeInBytes() / sizeof(T);
				this->Alloc = _Buffer.Alloc;

				_Buffer.Data = nullptr;
			}

			else throw std::bad_cast();

			return *this;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Direct buffer access.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto operator[] ( const u64 _Index ) const -> T& { return this->Data[_Index]; }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get buffer pointer.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto operator() ( void ) const -> T* { return this->Data; }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get casted buffer pointer to save few letter.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		template<typename C> inline constexpr auto cast ( void ) const -> C* { return reinterpret_cast<C*>(this->Data); }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get allocator.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto allocator ( void ) const -> Allocator& { return *this->Alloc; }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get buffer size in units.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto size ( void ) const -> u64 { return this->Size; }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get buffer size in bytes.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto sizeInBytes ( void ) const -> u64 { return (sizeof(T) * this->Size); }

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Zero memory.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto clear ( void ) -> void
		{
			static_assert(std::is_trivial<T>::value, "Error: fx->Buffer->clear()");
			std::memset(this->Data, 0, sizeof(T) * this->Size);
		}
		
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Free buffer.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto free ( void ) -> void
		{
			if(this->Data)
			{
				for(auto i = u64(0); i < this->Size; ++i) this->Data[i].~T();
				this->Alloc->free(this->Data);
			}

			this->Data = nullptr;
			this->Size = 0;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Delete old buffer and allocate new one.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto resize ( const u64 _Size ) -> void
		{
			this->free();
			this->Size = _Size;
			this->Data = reinterpret_cast<T*>(this->Alloc->alloc(sizeof(T) * this->Size));
			
			for(auto i = u64(0); i < this->Size; ++i) new (&this->Data[i]) T();
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Delete old buffer and allocate new one.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto resize ( const u64 _Size, Allocator& _Alloc ) -> void
		{
			this->free();
			this->Alloc = &_Alloc;
			this->resize(_Size);
		}
	};
}

