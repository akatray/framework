// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <fx/Simd.hpp>
#include <fx/Math.hpp>
#include <fx/Buffer.hpp>

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework - Gotta go fast.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace fx::simd
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Exchange massive amounts of memory for marginal improvements in perfomance.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	class ConvImage
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Data.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Buffer<r32> Data;
		u64 Width;
		u64 Height;
		u64 Depth;
		u64 Radius;
		u64 BlocksCount;
		u64 BlockSize;
		public:

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Default constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		ConvImage ( void ) = delete;

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Explicit constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		ConvImage ( const u64 _Width, const u64 _Height, const u64 _Depth, const u64 _Radius ) : Data(AllocSimd32), Width(_Width), Height(_Height), Depth(_Depth), Radius(_Radius)
		{
			this->BlocksCount = _Width * _Height * _Depth;
			this->BlockSize = ((this->Radius * 2) + 1) * ((this->Radius * 2) + 1);
			this->Data.resize(this->BlocksCount * this->BlockSize);
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Destructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		~ConvImage ( void )
		{
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Build cache blocks.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto build ( const r32* _Location ) -> void
		{
			auto Offset = u64(0);
			
			const auto RadiusMin = -i64(this->Radius);
			const auto RadiusMax = i64(this->Radius + 1);

			for(auto d = u64(0); d < this->Depth; ++d) { for(auto y = i64(0); y < i64(this->Height); ++y) { for(auto x = i64(0); x < i64(this->Width); ++x)
			{
				for(auto yf = RadiusMin; yf != RadiusMax; ++yf) { for(auto xf = RadiusMin; xf != RadiusMax; ++xf)
				{
					if(((x + xf) < 0) || ((y + yf) < 0) || ((x + xf) >= i64(this->Width)) || ((y + yf) >= i64(this->Height)))
					{
						this->Data[Offset] = 0.0f;
						++Offset;
					}

					else
					{
						this->Data[Offset] = _Location[math::index3d(x + xf, y + yf, d, this->Height, this->Depth)];
						++Offset;
					}
				}}
			}}}
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Apply filter.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto applyFilter ( r32* _Output, const r32* _Filter ) -> void
		{
			auto InData = this->Data();
			auto InFilter = _Filter;

			auto RegData = _mm256_set_ps(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
			auto RegFilter = _mm256_set_ps(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);
			auto RegResult = _mm256_set_ps(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);

			auto VecCount = u64((this->BlockSize - 1) / 8);
			
			auto x = u64(0);
			auto y = u64(0);
			auto d = u64(0);

			for(auto b = u64(0); b < this->BlocksCount; ++b)
			{
				RegResult = _mm256_set_ps(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);;
				
				for(auto v = u64(0); v < VecCount; ++v)
				{
					RegData = _mm256_load_ps(InData);
					RegFilter = _mm256_load_ps(InFilter);

					RegFilter = _mm256_mul_ps(RegData, RegFilter);

					RegResult = _mm256_add_ps(RegResult, RegFilter);

					InFilter += 8;
					InData += 8;
				}

				auto Unpack = reinterpret_cast<r32*>(&RegResult);
				_Output[math::index3d(x, y, d, this->Height, this->Depth)] = Unpack[0] + Unpack[1] + Unpack[2] + Unpack[3] + Unpack[4] + Unpack[5] + Unpack[6] + Unpack[7] + (*InData * *InFilter); // C++ Syntax == best syntax.

				InFilter = _Filter;
				InData += 1;

				++x;
				if(x == this->Width) {x=0;++y;}
				if(y == this->Height) {x=0;y=0;++d;}
			}
		}
	};
}