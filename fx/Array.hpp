// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "Types.hpp"
#include <cstring>

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace fx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// When std::vector is too smart and std::array is too stupid.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<typename DataType> struct Array
	{
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Data. Not intended to be accessed directly, but left public as an option.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		DataType* Data;
		u64 Size;
		u64 Next;
		u64 GrowthSize;

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Default constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Array ( void ) : Data(nullptr), Size(0), Next(0), GrowthSize(8) {}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Explicit constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Array ( const u64 _Size ) : Data(nullptr), Size(_Size), Next(0), GrowthSize(8)
		{
			this->resize(_Size);
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Copy constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Array ( const Array<DataType>& _Array ) : Data(nullptr), Size(0), Next(_Array.Next), GrowthSize(_Array.GrowthSize)
		{
			this->resize(_Array.Size);
			std::memcpy(this->Data, _Array.Data, sizeof(DataType) * this->Size);
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Move constructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Array ( Array<DataType>&& _Array ) : Data(_Array.Data), Size(_Array.Size), Next(_Array.Next), GrowthSize(_Array.GrowthSize)
		{
			_Array.Data = nullptr;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Destructor.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		~Array ( void )
		{
			if(this->Data) delete[] this->Data;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Copy assignment.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Array<DataType>& operator= ( const Array<DataType>& _Array )
		{
			if(this != &_Array)
			{
				this->Next = _Array.Next;
				this->GrowthSize = _Array.GrowthSize;
				
				this->resize(_Array.Size);
				std::memcpy(this->Data, _Array.Data, sizeof(DataType) * this->Size);
			}

			return *this;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Move assignment.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		Array<DataType>& operator= ( Array<DataType>&& _Array )
		{
			if(this != &_Array)
			{
				if(this->Data) delete[] this->Data;
				
				this->Data = _Array.Data;
				this->Size = _Array.Size;
				this->Next = _Array.Next;
				this->GrowthSize = _Array.GrowthSize;

				_Array.Data = nullptr;
			}

			return *this;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Direct buffer access. No checks if item is in buffer's bounds nor was item pushed in.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline DataType& operator[] ( const u64 _Index )
		{
			return this->Data[_Index];
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Return true if next == 0.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		inline auto isEmpty ( void ) -> bool const
		{
			if(this->Next == 0) return true;
			else return false;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Set next to 0. Memset buffer to 0.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto clear ( void ) -> void
		{
			this->Next = 0;
			std::memset(this->Data, 0, sizeof(DataType) * this->Size);
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Allocate new buffer with size + growth size and relocate items.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto grow ( void ) -> void
		{
			auto NewData = new DataType[this->Size + this->GrowthSize];
			
			if(this->Data)
			{
				std::memcpy(NewData, this->Data, sizeof(DataType) * this->Size);
				delete[] this->Data;
			}

			this->Data = NewData;
			this->Size += this->GrowthSize;
		}
		
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Set next item by value given. Increase next by 1. Increase buffer's size by growth size if buffer is full.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto push (const DataType& _Value) -> DataType&
		{
			if(this->Next == this->Size) this->grow();

			this->Data[this->Next] = _Value;
			++this->Next;

			return this->Data[this->Next - 1];
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Get last item. Reduce next by 1;
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto pull ( void ) -> DataType
		{
			if(this->Next != 0)
			{
				--this->Next;
				return this->Data[this->Next];
			}

			return DataType();
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Allocate new buffer with given size. Optionaly relocate as much old items that can fit new size.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto resize ( const u64 _Size, const bool _Relocate = false ) -> void
		{
			auto NewData = new DataType[_Size];

			if(this->Data)
			{
				if(_Relocate)
				{
					auto RelocateSize = u64(0);

					if(_Size >= (this->Next - 1)) RelocateSize = this->Next - 1;

					else
					{
						RelocateSize = _Size;
						this->Next = _Size + 1;
					}
				
					std::memcpy(NewData, this->Data, sizeof(DataType) * RelocateSize);
				}

				else this->Next = 0;

				delete[] this->Data;
			}

			this->Data = NewData;
			this->Size = _Size;
		}

		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		// Allocate new buffer that fits items perfectly.
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		auto fit ( void ) -> void
		{
			if(this->Data)
			{
				if(this->Next == 0)
				{
					delete[] this->Data;
				}

				else
				{
					auto NewData = new DataType[this->Next];
					std::memcpy(NewData, this->Data, sizeof(DataType) * this->Next);

					delete[] this->Data;
					this->Data = NewData;
					this->Size = this->Next;
				}
			}
		}
	};
}

