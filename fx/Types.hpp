// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <cstdint>
#include <string>
#include <type_traits>

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace fx
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Type renaming.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	using ptr = void*;
	
	using u8 = std::uint8_t;
	using u16 = std::uint16_t;
	using u32 = std::uint32_t;
	using u64 = std::uint64_t;

	using i8 = std::int8_t;
	using i16 = std::int16_t;
	using i32 = std::int32_t;
	using i64 = std::int64_t;

	using r32 = float;
	using r64 = double;

	using str = std::string;
	using namespace std::string_literals;

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Check if types match their expected size.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	static_assert(sizeof(ptr) == 8, "Size of fx::ptr is not 8!");
	
	static_assert(sizeof(u8) == 1, "Size of fx::u8 is not 1!");
	static_assert(sizeof(u16) == 2, "Size of fx::u16 is not 2!");
	static_assert(sizeof(u32) == 4, "Size of fx::u32 is not 4!");
	static_assert(sizeof(u64) == 8, "Size of fx::u64 is not 8!");
	
	static_assert(sizeof(i8) == 1, "Size of fx::i8 is not 1!");
	static_assert(sizeof(i16) == 2, "Size of fx::i16 is not 2!");
	static_assert(sizeof(i32) == 4, "Size of fx::i32 is not 4!");
	static_assert(sizeof(i64) == 8, "Size of fx::i64 is not 8!");
	
	static_assert(sizeof(r32) == 4, "Size of fx::r32 is not 4!");
	static_assert(sizeof(r64) == 8, "Size of fx::r64 is not 8!");

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr auto initTypeMax ( void )
	{
		if constexpr(std::is_integral_v<T>)
		{
			if constexpr(std::is_signed_v<T>) return i64(0);
			else return u64(0);
		}

		else if constexpr(std::is_floating_point_v<T>) return r64(0.0);

		else static_assert(false, "fx::initMaxType | Type not implemented.");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Enum for types.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	enum struct TypeToken
	{
		U8,
		U16,
		U32,
		U64,
		I8,
		I16,
		I32,
		I64,
		R32,
		R64
	};

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get type size by token.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto getTypeSize ( const TypeToken _Type ) -> u64
	{
		if(_Type == TypeToken::U8) return sizeof(u8);
		if(_Type == TypeToken::U16) return sizeof(u16);
		if(_Type == TypeToken::U32) return sizeof(u32);
		if(_Type == TypeToken::U64) return sizeof(u64);
		if(_Type == TypeToken::I8) return sizeof(i8);
		if(_Type == TypeToken::I16) return sizeof(i16);
		if(_Type == TypeToken::I32) return sizeof(i32);
		if(_Type == TypeToken::I64) return sizeof(i64);
		if(_Type == TypeToken::R32) return sizeof(r32);
		if(_Type == TypeToken::R64) return sizeof(r64);

		return 0;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get type name by token.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	inline auto getTypeName ( const TypeToken _Type ) -> str
	{
		if(_Type == TypeToken::U8) return str("u8");
		if(_Type == TypeToken::U16) return str("u16");
		if(_Type == TypeToken::U32) return str("u32");
		if(_Type == TypeToken::U64) return str("u64");
		if(_Type == TypeToken::I8) return str("i8");
		if(_Type == TypeToken::I16) return str("i16");
		if(_Type == TypeToken::I32) return str("i32");
		if(_Type == TypeToken::I64) return str("i64");
		if(_Type == TypeToken::R32) return str("r32");
		if(_Type == TypeToken::R64) return str("r64");

		return str("none");
	}
}