// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "Types.hpp"
#include <algorithm>
#include <execution>
#include <type_traits>
#include <cmath>
#include <numeric>

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework - Blackmagic.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace fx::math
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Sum += e^_X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto sum_exp ( const uMAX _Size, const T* _X )
	{
		return std::accumulate(_X, _X + _Size, T(0), [&]( T _Sum, T _Item ) { return _Sum + std::exp(_Item); });
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// X*X.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto sqr ( const T _X ) { return _X * _X; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Normalize value to 0..1 range.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto normalize ( const T _Val, const T _Min, const T _Max )
	{
		return (_Val - _Min) / (_Max - _Min);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Mean value of _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, class Y = T> constexpr auto mean ( const uMAX _Size, const T* _X ) -> Y { return std::accumulate(_X, _X + _Size, Y(0)) / _Size; }
	template<class T, class Y = T> constexpr auto mean_sqr ( const uMAX _Size, const T* _X ) -> Y { return std::inner_product(_X, _X + _Size, _X, Y(0)) / _Size; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get standard deviation of _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr auto stddev ( const uMAX _Size, const T* _X, const T _Mean ) -> T
	{
		return std::sqrt(std::accumulate(_X, _X + _Size, T(), [&]( T _Sum, T _Item ) { return _Sum + sqr(_Item - _Mean); }));
	}

	template<class T> constexpr auto stddev ( const uMAX _Size, const T* _X ) -> T
	{
		return stddev(_Size, _X, mean(_Size, _X));
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get standard deviation of vector _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto stddev_zeromean ( const u64 _Size, T* _X )
	{
		const auto Mean = mean(_Size, _X);
		for(auto i = u64(0); i < _Size; ++i) _X[i] -= Mean;

		const auto Deviation = std::sqrt(mean_sqr(_Size, _X) / _Size);
		for(auto i = u64(0); i < _Size; ++i) _X[i] /= Deviation;
	}
	
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Check if number is even.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto isEven ( const T _Val ) -> bool
	{
		if constexpr(std::is_integral_v<T>)
		{
			if(_Val % 2 == 0) return true;
			else return false;
		}

		else static_assert(false, "T does not satisfy requirements!");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 2D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _MaxY) -> u64 { return _Y + _MaxY * _X; }
	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _MaxX) -> u64 { return _X + _MaxX * _Y; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 3D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _MaxY, const u64 _MaxZ ) -> u64
	{
		return _Z + _MaxZ * (_Y + _MaxY * _X);
	}

	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _MaxX, const u64 _MaxY ) -> u64
	{
		return _X + _MaxX * (_Y + _MaxY * _Z);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 4D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _W, const u64 _MaxY, const u64 _MaxZ, const u64 _MaxW ) -> u64
	{
		return _W + _MaxW * (_Z + _MaxZ * (_Y + _MaxY * _X));
	}

	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _W, const u64 _MaxX, const u64 _MaxY, const u64 _MaxZ ) -> u64
	{
		return _X + _MaxX * (_Y + _MaxY * (_Z + _MaxZ * _W));
	}


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto factorial ( const T _X ) -> T
	{
		auto Fact = T(1);
		for(auto i = T(1); i <= _X; ++i) Fact *= i;
		return Fact;
	}
}
