// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "Types.hpp"
#include <algorithm>
#include <execution>
#include <type_traits>
#include <cmath>
#include <numeric>

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework - Blackmagic.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace fx::math
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Constants.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr auto EULER = 2.7182818284590452353602874713527;
	constexpr auto PI = 3.14159;

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Sums _X[] values.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto sum ( const uMAX _Size, const T* _X )
	{
		return std::accumulate(_X, _X + _Size, T(0));
	}

	template<class T> constexpr inline auto sum_exp ( const uMAX _Size, const T* _X )
	{
		return std::accumulate(_X, _X + _Size, T(0), [&]( T _Sum, T _Item ) { return _Sum + std::exp(_Item); });
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// X*X.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto sqr ( const T _X ) -> T { return _X * _X; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Normalize value to 0..1 range.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto normalize ( const T _Val, const T _Min, const T _Max ) -> T
	{
		return (_Val - _Min) / (_Max - _Min);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Gets magnitude of vector _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto mag ( const u64 _Size, const T* _X ) -> T
	{
		auto Mag = T(0);
		for(auto i = u64(0); i < _Size; ++i) Mag += sqr(_X[i]);
		return std::sqrt(Mag);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Normalize vector _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto normalize ( const u64 _Size, T* _X, T _Mag ) -> void
	{
		for(auto n = u64(0); n < _Size; ++n) _X[n] /= _Mag;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Mean value of _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T, class Y = T> constexpr auto mean ( const uMAX _Size, const T* _X ) -> Y { return std::accumulate(_X, _X + _Size, Y(0)) / _Size; }
	template<class T> constexpr auto mean_sqr ( const uMAX _Size, const T* _X ) -> T { return std::inner_product(_X, _X + _Size, _X, T(0)) / _Size; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get standard deviation of _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr auto stddev ( const uMAX _Size, const T* _X, const T _Mean ) -> T
	{
		return std::sqrt(std::accumulate(_X, _X + _Size, T(), [&]( T _Sum, T _Item ) { return _Sum + sqr(_Item - _Mean); }));
	}

	template<class T> constexpr auto stddev ( const uMAX _Size, const T* _X ) -> T
	{
		return stddev(_Size, _X, mean(_Size, _X));
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get standard deviation of vector _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto stddev_zeromean ( const u64 _Size, T* _X )
	{
		const auto Mean = mean(_Size, _X);
		for(auto i = u64(0); i < _Size; ++i) _X[i] -= Mean;

		const auto Deviation = std::sqrt(mean_sqr(_Size, _X) / _Size);
		for(auto i = u64(0); i < _Size; ++i) _X[i] /= Deviation;
	}
	
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Linear interpolation.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto lerp ( const T _A, const T _B, const T _T ) -> T
	{
		if constexpr(std::is_floating_point_v<T>) return _A + _T * (_B - _A);
		else static_assert(false, "T does not satisfy requirements!");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Linear interpolation. Precise version.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto lerp2 ( const T _A, const T _B, const T _T ) -> T
	{
		if constexpr(std::is_floating_point_v<T>) return (T(1) - _T) * _A + _T * _B;
		else static_assert(false, "T does not satisfy requirements!");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Check if number is even.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto isEven ( const T _Val ) -> bool
	{
		if constexpr(std::is_integral_v<T>)
		{
			if(_Val % 2 == 0) return true;
			else return false;
		}

		else static_assert(false, "T does not satisfy requirements!");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 2D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _MaxY) -> u64 { return _Y + _MaxY * _X; }
	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _MaxX) -> u64 { return _X + _MaxX * _Y; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 3D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _MaxY, const u64 _MaxZ ) -> u64
	{
		return _Z + _MaxZ * (_Y + _MaxY * _X);
	}

	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _MaxX, const u64 _MaxY ) -> u64
	{
		return _X + _MaxX * (_Y + _MaxY * _Z);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 4D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _W, const u64 _MaxY, const u64 _MaxZ, const u64 _MaxW ) -> u64
	{
		return _W + _MaxW * (_Z + _MaxZ * (_Y + _MaxY * _X));
	}

	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _W, const u64 _MaxX, const u64 _MaxY, const u64 _MaxZ ) -> u64
	{
		return _X + _MaxX * (_Y + _MaxY * (_Z + _MaxZ * _W));
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Mean Squared Error.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> inline auto mse ( const T _Real, const T _Ideal ) -> T { return std::pow(_Real - _Ideal, 2); }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Mean Squared Error of an array.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> inline auto mse ( const u64 _Size, const T* _Real, const T* _Ideal ) -> T
	{
		auto Sum = T(0);

		for(auto n = u64(0); n < _Size; ++n) Sum += std::pow(_Real[n] - _Ideal[n], 2);

		return Sum / _Size;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto factorial ( const T _X ) -> T
	{
		auto Fact = T(1);
		for(auto i = T(1); i <= _X; ++i) Fact *= i;
		return Fact;
	}

	template<class T> constexpr inline auto exp ( const T _X ) -> T
	{
		auto Fact = T(1);
		for(auto i = T(1); i <= _X; ++i) Fact *= i;
		return Fact;
	}


}
