// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Pragma.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#pragma once

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Imports.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include "Types.hpp"
#include <type_traits>
#include <cmath>
#include <numeric>

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Framework - Blackmagic.
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
namespace fx::math
{
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Constants.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr auto E = r32(2.71828f);
	constexpr auto PI = r32(3.14159f);

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// X*X.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto sqr ( const T _X ) -> T { return _X * _X; }


	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Sums _X[] values.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto sum ( const u64 _Size, const T* _X ) -> T
	{
		auto Sum = T(0);
		for(auto n = u64(0); n < _Size; ++n) Sum += _X[n];

		return Sum;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Gets magnitude of vector _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto mag ( const u64 _Size, const T* _X ) -> T
	{
		auto Mag = T(0);
		for(auto n = u64(0); n < _Size; ++n) Mag += sqr(_X[n]);
		return std::sqrt(Mag);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Normalize vector _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto normalize ( const u64 _Size, T* _X, T _Mag ) -> void
	{
		for(auto n = u64(0); n < _Size; ++n) _X[n] /= _Mag;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get average value in _X[].
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto mean ( const u64 _Size, const T* _X ) -> T { return sum(_Size, _X) / _Size; }
	
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Variance between two values.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto var ( const T _Mean, const T _X, const T _Y ) -> T
	{
		return (sqr(_Mean - _X) + sqr(_Mean - _Y)) / 2;
	}

	template<class T> constexpr inline auto var ( const u64 _Size, const T _Mean, const T* _X ) -> T
	{
		auto Sum = T();
		for(auto n = u64(0); n < _Size; ++n) Sum += sqr(_Mean - _X[n]);

		return Sum / _Size;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Covariance between two values.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto cov ( const T _MeanX, const T _MeanY, const T _X, const T _Y ) -> T
	{
		return (_X - _MeanX) * (_Y - _MeanY);
	}

	template<class T> constexpr inline auto cov ( const u64 _Size, const T _MeanX, const T _MeanY, const T* _X, const T* _Y ) -> T
	{
		auto Sum = T();
		for(auto n = u64(0); n < _Size; ++n) Sum += (_X[n] - _MeanX) * (_Y[n] - _MeanY);
		
		return Sum / _Size;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// 
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto ssim ( const u64 _Size, const T* _X, const T* _Y ) -> T
	{
		auto MeanX = mean(_Size, _X);
		auto MeanY = mean(_Size, _Y);
		auto VarX = var(_Size, MeanX, _X);
		auto VarY = var(_Size, MeanY, _Y);
		auto CovXY = cov(_Size, MeanX, MeanY, _X, _Y);

		auto C1 = 6.5025;
		auto C2 = 58.5225;

		return ((2 * MeanX * MeanY + C1) * (2 * CovXY + C2)) / ((sqr(MeanX) + sqr(MeanY) + C1) * (sqr(VarX) + sqr(VarY) + C2));
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Linear interpolation.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto lerp ( const T _A, const T _B, const T _T ) -> T
	{
		if constexpr(std::is_floating_point_v<T>) return _A + _T * (_B - _A);
		else static_assert(false, "T does not satisfy requirements!");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Linear interpolation. Precise version.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto lerp2 ( const T _A, const T _B, const T _T ) -> T
	{
		if constexpr(std::is_floating_point_v<T>) return (T(1) - _T) * _A + _T * _B;
		else static_assert(false, "T does not satisfy requirements!");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Check if number is even.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> constexpr inline auto isEven ( const T _Val ) -> bool
	{
		if constexpr(std::is_integral_v<T>)
		{
			if(_Val % 2 == 0) return true;
			else return false;
		}

		else static_assert(false, "T does not satisfy requirements!");
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 2D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _MaxY) -> u64 { return _Y + _MaxY * _X; }
	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _MaxX) -> u64 { return _X + _MaxX * _Y; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 3D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _MaxY, const u64 _MaxZ ) -> u64
	{
		return _Z + _MaxZ * (_Y + _MaxY * _X);
	}

	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _MaxX, const u64 _MaxY ) -> u64
	{
		return _X + _MaxX * (_Y + _MaxY * _Z);
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Get index into 1D array from 4D coordinates.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto index_r ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _W, const u64 _MaxY, const u64 _MaxZ, const u64 _MaxW ) -> u64
	{
		return _W + _MaxW * (_Z + _MaxZ * (_Y + _MaxY * _X));
	}

	constexpr inline auto index_c ( const u64 _X, const u64 _Y, const u64 _Z, const u64 _W, const u64 _MaxX, const u64 _MaxY, const u64 _MaxZ ) -> u64
	{
		return _X + _MaxX * (_Y + _MaxY * (_Z + _MaxZ * _W));
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Mean Squared Error: One item.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> inline auto mse ( const T _Real, const T _Ideal ) -> T { return std::pow(_Real - _Ideal, 2); }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Mean Squared Error: Many items.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	template<class T> inline auto mse (const u64 _Size, const T* _Real, const T* _Ideal) -> T
	{
		auto Sum = T(0);

		for(auto n = u64(0); n < _Size; ++n) Sum += std::pow(_Real[n] - _Ideal[n], 2);

		return Sum / _Size;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Logistic.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	inline auto sigmoid ( const r32 _X ) -> r32 { return (1.0f / (1.0f + std::powf(E, -_X))); }
	inline auto sigmoidDer ( const r32 _X ) -> r32 { return (sigmoid(_X) * (1.0f - sigmoid(_X))); }
	constexpr inline auto sigmoidDer2 ( const r32 _FX ) -> r32 { return (_FX * (1.0f - _FX)); }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// TanH.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	inline auto tanh ( const r32 _X ) -> r32 { return (2.0f / (1.0f + std::powf(E, -_X * 2.0f))) - 1.0f; }
	inline auto tanhDer2 ( const r32 _FX ) -> r32 { return 1.0f - std::powf(_FX, 2.0f); }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// REctified Linear Unit.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto relu ( const r32 _X ) -> r32 { return std::max(0.0f, _X); }
	constexpr inline auto reluDer ( const r32 _X ) -> r32 { if(_X >= 0.0f) return 1.0f; else return 0.0f; }

	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Parametric REctified Linear Unit.
	// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	constexpr inline auto prelu (const r32 _X, const r32 _A = 0.2f ) -> r32 { if(_X >= 0.0f) return _X; else return _X * _A; }
	constexpr inline auto preluDer (const r32 _X, const r32 _A = 0.2f) -> r32 { if(_X >= 0.0f) return 1.0f; else return _A; }

}